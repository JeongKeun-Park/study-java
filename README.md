JAVA - 프로그래밍 언어

		프로그래밍 언어는 개발자와 운영체제가 소통하기 위한 언어이다.

소스코드

		명령어를 작성해 놓은 것.
		개발자와 운영체제가 소통할 것을 글로 작성해 놓은 것.

소스파일

		소스코드를 작성해 놓은 파일.

컴파일

		사람의 언어를 컴퓨터 언어로 바꿔주는 작업.

컴파일러

		컴파일을 해주는 프로그램 또는 명령어
		컴파일러는 위에서 아래로, 좌에서 우로 번역한다.

프로그램

		소스코드로 잘 짜여진 툴.

콘솔

		개발자와 운영체제가 소통한 결과를 보여주는 창.(리눅스 공부하면 좋음)

▶일반 프로그램

		프로그램
		OS(운영체제) : 하드웨어에 적절한 전기신호를 흘려주는 역할.
		하드웨어 : 

▶JAVA 프로그램

		JAVA 프로그램
		JVM : JAVA 프로그램을 OS에 맞게 변환해준다.
		OS(운영체제) : 하드웨어에 적절한 전기신호를 흘려주는 역할.
		하드웨어 

		- 이식성이 좋다.
_____________________________________________________________________________________________________
JVM(Java VIrtual Machine)

		JAVA 프로그램을 실행해 줌.

JRE(Java Runtime Environment)

		JVM을 생성하며, 실행할 때 필요한 라이브러리 파일들을 가지고 있다.

JDK(Java Development Kit)

		JRE 안에 개발에 필요한 도구들을 가지고 있다.
		컴파일 명령어와 실행 명령어를 담고있다.
_____________________________________________________________________________________________________
JDK 설치

    환경변수 편집
    JAVA_HOME 변수선언하고 경로를 값으로 설정
    Path로 가서 %JAVA_HOME%\bin을 추가하고 맨위로 올리기
		    //변수명은 %로 감싸고 그뒤에 추가경로를 적는다

IDE 설치

		- 이클립스


		-인텔리제이
_____________________________________________________________________________________________________
    기본 구조
		    프로젝트
				    패키지
						    클래스
								    메소드
										    소스코드

    함수 : 어딘가에 갇혀있지 않다
    메소드 : 어딘가에 갇혀있다.
    windows/Preference/compile확인 font확인 (consolas)

    단축키, 설정
    컴파일 과정 : 디버그 -> 빌드 -> 링크 -> 실행
    ctrl m 영역확대
    art shift q 각 영역 보여주기
    ctrl f11 콘솔창 출력
    ctrl alt 방향키 -> 복사
    ctrl shift f 자동줄정렬
_____________________________________________________________________________________________________
출력 메소드

	1. print( ) : 마지막에 자동으로 줄바꿈되지 않고 아래 문장과 이어서 출력된다.
	2. println ( ) : 마지막에 자동으로 줄바꿈된다.
	3. printf( ) : 

출력 메소드를 사용하는 이유

	데이터를 사용하기 위해서 사용하는 도구이다.
	*오류를 구체화하기 위해 사용하는 도구이다.*
	즉, 출력 메소드는 개발자를 위한 도구이다.

_____________________________________________________________________________________________________
변수

	변수는 저장공간이다.

	x		=		10
    저장공간의	대입		값(상수)
	이름		연산자

자료형(type)

	자요형은 저장공간의 종류이다.

	자료형		type			byte			값

	정수형		byte			1			4, 1, -120, 100, ....
				short			2			9, 150, -55, ...
				int(defalt)		4			1234, 34234, -2121453442, ...
				long			8			231245234631L, -234135215235L, ...

	실수형		float			4			3.7F, -0.93F, ....
				double(defalt)	8			32.12, 182.2341, ...

	문자형		char			2			'A', '0', '안', ...
	java는 유닛코드

	문자열		Srting			???			"ABC", "12.52", "123", "안녕", ...

변수의 선언

	자료형 변수명 = 초기값 ;		◀ 초기화
 
	자료형 변수명;

	ex)
	int x = 10;
	x라는 이름의 정수형 저장공간이 할당(allocation)되고 그 안에 10이 들어간다.

변수의 초기값

	정수 : 0
	실수 : 0.0
	문자 : ' ' -> 공백이 들어가있다.
	문자열 : "", null

변수의 사용

	저장공간의 확인단계
	1단계 : 자료형을 확인한다.
	2단계 : 대입 연산자를 확인한다.

	int data = 10;	// 저장공간
	data + 9;		// 값
	data = data + 99	// 저장공간, 값
_____________________________________________________________________________________________________
상수

	항상 그대로인 수
	값을 변경할 수 없도록 한다.

	final 자료형 상수명 = 값;

상수를 사용하는 이유

	값에 의미부여를 하기 위해서
_____________________________________________________________________________________________________
형변환

	- 자동 형변환
		정수 + 정수 = 정수
		정수 + 실수 = 실수
		정수 + 문자 = 정수

		3 + 0.0 = 3.0
		10 / 3 = 3
		10 % 1 = 1
		'A' + 3 = 68

	- 강제 형변환
		(자료형)값
		(double)3

문자열 형변환

	1. 다른 자료형을 문자열로
		문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.

	2. 문자열을 다른 자료형으로
		일반 자료형은 일반 자료형끼리만 형 변환이 가능하다.
		문자열 타입은 클래스 타입이므로, 일반 자료형의 클래스 타입의 도움을 받아야한다.

		Integer.parseInt("") => 문자열에서 변환(추출)된 정수
		Double.parseDouble("") => 문자열에서 변환(추출)된 실수
_____________________________________________________________________________________________________
입력

	커서가 깜빡이고 있는 상태를 입력상태라고 한다.
	입력하기 전에 출력을 통해 어떤 값을 입력해야 할지 사용자에게 알려줘야 한다.

입력 클래스

	Scanner sc= new Scanner(System.in);
	자료형 변수명		값

입력 메소드

	next() : 사용자가 입력한 문자열 값
			- 사용자가 입력한 값 중 공백 또는 줄바꿈 문자(엔터)를 구분점으로 각 문자열을 분리한다.
			- 첫 번째 문자열은 첫 번째 next()에 담긴다.
			  두 번째 문자열은 두 번째 next()에 담긴다.
			  ...

	nextLine() : 사용자가 입력한 문자열 값
			- 공백 또는 줄바꿈 문자도 모두 값으로 취급하기 때문에 그대로 입력받는다.
_____________________________________________________________________________________________________
연산자

	기능이 있는 특수문자

연산자의 우선순위

	최우선 연산자
	단항 연산자
	산술 연산자
	쉬프트 연산자
	관계 연산자
	논리 연산자
	삼항 연산자
	대입 연산자

결합성

	하나의 수식에 동일한 연산자가 여러 개 사용되면 알맞은 방향으로 결합되어 연산되는 성질
_____________________________________________________________________________________________________
논리형(boolean)

	참 : true
	거짓 : false

	초기값 : false ;

	boolean(1byte) = true, false
	boolean check = true;

조건식

	결과가 참 또는 거짓 둘중 하나가 나오는 식

관계 연산자

      ==   같다
      !=   같지 않다
      >, <   초과, 미만
      >=, <=   이상, 이하


논리 연산자
  
      && (AND), A && B   두 조건식 모두 참이면 참
      || (OR), A || B      둘 중 하나라도 참이면 참

   
단항 연산자

      ! (NOT), !A      조건식이 참이면 거짓으로, 거짓이면 참으로 변경


삼항 연산자

      ? :   조건식 ? 참 : 거짓, 조건식이 참이면 참, 거짓이면 거짓
      예) int result = 10 > 11 ? 10 : 11;
      
      ※ 한 개의 조건식만 있을 때 사용하는 것이 좋다.
_____________________________________________________________________________________________________
배열: 저장공간의 나열

     1.
      변수를 여러 개 선언하면 이름도 여러 개 생긴다. 이 때 각 저장공간을 관리하기 불편하다.
      따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고, 이름도 한 개이기 때문에
      관리하기 편하다.

     2.
      규칙성이 없는 값에 규칙성을 부여하기 위해서

배열의 선언

     자료형[] 배열명 = {값1, 값2, ... }; // 어떤 값을 넣을지 알 때 사용한다.
     자료형[] 배열명 = new 자료형[칸수]; // 어떤 값을 넣을지는 모르나, 몇 칸 만들지는 알 때 사용한다.
     자료형[] 배열명 = null; // 어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용한다.

     ※ new: Heap 메모리에 할당, 초기값으로 자동 초기화
     ※ null: 주소의 초기값, 어떤 주소를 넣을지 모를 때 작성하는 값
     ※ 자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적 배열만 존재한다.

배열의 구조

     int[] arData = {3, 5, 1, 2, 8};

     arData라는 이름의 저장공간 한 개 만들어지며, 여기에는 한 개의 값만 담을 수 있다.
     5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다.
     5칸의 저장공간 중 첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며,
     다음 주소에 접근하기 위해서는 + n을 한다.
     예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며, 
     *(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다.
     JAVA에서는 직접 주소에 접근하는 연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용한다.
     arData[2]로 사용한다. 각각의 방 번호는 index라고 부르며, 시작주소를 가지고 있기 때문에
     인덱스 번호는 항상 0부터 시작된다.

length

     배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.
     배열명.length

배열의 사용

     int[] arData = new int[5];      // 저장공간 (int[5]는 5라는 값이 아니라 5칸이 생성됐다는 뜻이다.)
     arData[0] = 120;         // 저장공간
     arData[0] + 9;         // 값
     System.out.println(arData);      // 주소값
     arData[2] = arData[0] + arData[1];   // 저장공간, 값
     System.out.println(arData[5]);      // 오류
_____________________________________________________________________________________________________
2차원 배열 : 배열 안에 배열 ( 행 : 세로, 열 : 가로)

	1차원 배열을 여러개 선언하면, 관리하기 어렵다.
	2차원 배열을 한번만 선언하자!

	※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

2차원 배열 선언

					1행		2행
	자료형[][] 배열명 = {{값1, 값2, ...}, {값3, 값4, ...};
	자료형[][] 배열명 = new 자료형[][];
	자료형[][] 배열명 = null;

	int[][] arrData = new int[2][3];

	의 면 행 열
	[]
	[3][]
	[][][]
_____________________________________________________________________________________________________
클래스(반)

	공통 요소를 한 번만 선언해놓고 사용하도록 설계한다.

	1. 타입이다.(자료형이다)
		클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
		해당 클래스 타입으로 변수를 선언해야 한다.

	2. 주어이다.
		Monkey.eat("바나나");
		원숭이가 먹는다 바나나를

클래스 선언

	class 클래스명 {
		필드(변수, 메소드)
	}

클래스의 필드 사용

	객체화 (instance) : 객체(instance variable)를 만드는 작업, 추상적인 개념을 구체화 시키는 작업
				  클래스명 객체명 = new 생성자();
				  ※ .(마침표) : 하위 연산자, 멤버 변수 접근 연산자, 닷 연산자, 점 연산자
				  주소값 뒤에서만 사용이 가능하며, 해당 주소를 참조하는 명령어이다.
	
 
 생성자
 
	클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능이 똑같지만 메소드라고 부르지 않는다.
	생성자는 리턴이라는 기능이 존재하지 않기 때문이다.

	1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다.
	2. 초기화

기본 생성자

	매개변수가 없는 생성자이며, 클래스 선언 시 컴파일러가 자동으로 작성해준다.
	만약 직접 생성자를 선언하게 되면, 더이상 컴파일러가 작성해주지 않는다.

this

	필드에 접근한 객체가 누군지 알아야 해당 필드에 접근할 수 있다.
	이 때 접근한 객체가 가지고 있는 필드의 주소값이 this라는 변수에 자동으로 담긴다.

다형성(Polymorphism)

	1. 오버 로딩(Overloading)
		매개변수의 개수 혹은 타입이 다르면 동일한 이름의 메소드로 선언할 수 있다.

배열과 클래스의 차이점

	배열은 같은 자료형만 담을 수 있으며, 각 방을 번호(index)로 기억해야 한다.
	순서가 있어야 하는 것 또는 처음부터 끝까지 가져오는 작업이라면 배열에 담는 것이 좋다
	클래스는 서로 다른 자료형도 담을 수 있으며, 각 값은 전부 이름을 붙여서 필드로 구성한다.
	원하는 값을 가져오고 싶다면, 클래스로 가져오는 것이 훨씬 낫다.
_____________________________________________________________________________________________________
상속(inheritance)

	1. 기존에 선언된 클래스의 필드를 다른 클래스의 필드로 사용하고자 할 때
	2. 여러 클래스 선언 시 필드가 겹칠 때 공통 필드를 묶고자 할 때
	   
상속 문법

	class A {
		A 필드
	}

	class B extends A{
		A, B 필드
	}

    A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
    B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

super() : 부모 생성자

	자식 클래스 타입의 객체는 부모 필드에 접근할 수 있다.
	하지만 자식 생성자만 호출하기 떄문에, 자식 필드만 메모리에 할당 된다.
	그렇기 때문에 B 타입의 객체로 A필드인 부모 필드에 접근할 수 없어야 정상이다.
	사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출 시
	부모와 자식 필드 모두 메모리에 할당된다. 이 때, 부모 생성자를 호출하는 방법은
	super()를 사용하는 것이다. 만약 super()를 작성하지 않더라도 컴파일러가 자동으로 작성해 준다.
	만약 직접 super()를 작성한다면 부모 생성자가 먼저 호출되어야 하기 때문에
	영역의 최상단에 작성해야 한다.

다형성(Polymorphism)

	1. 오버로딩
	2. 오버라이딩(Overriding) //무시하다, 재정의
		부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의 한다.
		같은 이름의 메소드로 선언하면, 자식 객체로 접근했을 때 가까운 곳에서 찾기 때문에
		자식 필드에서 재정의된 메소드가 사용된다.
		이 때 부모의 메소드를 사용하고 싶다면, 재정의한 메소드 안에서 super로 접근할 수 있다.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
모든 자식은 부모 타입이다.

Casting

	구현되지 않은 메소드가 있다면 메모리에 올릴 수 없다.

	1. up casting
		자식 값을 부모 타입으로 형변환

		부모 객체 = new 자식생성자();
	2. down casting
		up casting 된 객체를 다시 자식 타입으로 형변환

		(자식 클래스)up casting된 객체

	※ 부모 값을 자식 타입으로 형변환 시 오류 발생

타입 검사

	instanceof

	객체 instanceof 타입
	1. 같은 자료형이면 true
	2. 다른 자료형이면 false

Casting을 잘 사용하는 방법

	모든 자식들을 하나의 타입으로 묶을 때 up casting을 진행한다.
	전달받은 자식 객체가 어떤 타입인지 검사한 뒤
	해당 타입으로 down casting을 진행한다.
	즉 묶어서 하나의 타입으로 받고, 다시 원래 타입으로 복구하자!

접근 권한 제어자(접근자)

	1. default 	: 다른 패키지에서 접근 불가
	2. public	: 모든 곳에서 접근 가능, 만약 클래스 앞에 붙인다면 메인 클래스를 의미한다.
	3. protected	: 다른 패키지에서 접근 불가, 자식은 가능, 1개의 객체만 사용해야 할 때
	4. private	: 다른 클래스에서 접근 불가, 메소드로 접근하라는 의미로 사용한다.
			  ※ private 필드는 getter와 setter를 만들자
_____________________________________________________________________________________________________
추상 클래스

	필드 안에 구현이 안된 메소드가 선언되어 있는 클래스를 추상 클래스라고 한다.
	이 때 구현되지 않은 메소드를 추상 메소드라고 부른다.
	즉, 추상 클래스에 추상 메소드를 선언 할 수 있다.
	이는 반드시 구현해야 하기 때문에 "강제성"을 부여할 수 있게 된다.

추상 클래스 선언

	abstract class 클래스명 {
			abstract 리턴타입 메소드명 (매개변수, ...);
			일반 메소드도 선언 가능하다.
	}

인터페이스(틀)

	추상 클래스를 고도화시킨 문법, 상수와 추상메소드만 존재한다.
	구현은 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는 
	implements 키워드를 사용한다.

추상 클래스와 인터페이스 간의 관계

	인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되기 때문에
	전부 다 구현해야 한다. 하지만 일반적인 상황에서는 필요한 메소드를 골라서 재정의한다.
	따라서 인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 구현해 놓는다면,
	강제성이 소멸되고 이로 인해 골라서 재정의할 수 있게 된다.
	이 때 중간에서 강제성을 없애주는 클래스를 추상클래스로 선언하기로 하며,
	추상 클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다.

내부 클래스(inner class)

	어떤 영역 안에 클래스가 선언되면 내부 클래스라고 한다.

익명 클래스(Anonymous Inner Class)

	이름이 없는 클래스이며, 구현되지 않은 필드를 구현하기 위해서 일회성으로 생성되는 클래스이다.
_____________________________________________________________________________________________________
함수형 인터페이스(Functional Interface)

	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
	이 때 @FunctinoalInterfave를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언하도록 한다.


람다식(Lamdda Exprssion)

	함수형 인터페이스에서는 한개의 추상메소드만 존재하기 떄문에 구현 시 메소드 이름이 딱히 필요가 없다.
	람다식은 이름이 없는 메소드로서, 값처럼 사용이 가능하고 당연히 매개변수로도 전달이 가능하다.
	따라서 람다식을 익명 메소드라고도 부른다.

람다식 문법

	1. (매개변수 형식 나열, ...) -> 리턴값;
	2. (매개변수 형식 나열, ...) -> {실행할 문장; return 리턴값;};
	3. 매개변수 -> 리턴값; 
	4. 매개변수 -> {실행할 문장; return 리턴값;};
	보통 1,2번 형식을 사용
_____________________________________________________________________________________________________
예외 처리

	에러 : 심각한 오류
	예외 : 덜 심각한 오류

	컴파일 시, 빌드 시, 런타임 시 오류가 발생하면 제어문 혹은 문법 교정을 통해 막을 수 있지만
	아예 막을 수 없는 상황도 발생한다. 컴퓨터에 이상이 생길 정도로 심각한 오류는 에러라고 표현하고
	프로그램에 이상이 생긴 것을 예외라고 부른다. 하지만 정해진 용어는 정확히 없으니 보통 "오류"라고 부른다.
	프로그램이 강제 종료되는 것을 막는게 예외 처리의 목적이다.

예외 처리 문법

	try {
		오류가 발생할 수 있는 문장;
	}
	catch(예외이름 객체명){
		오류 발생 시 실행할 문장;
	}
	catch(예외이름 객체명){
		오류 발생 시 실행할 문장;
	}
	...
	finally {
		catch애서 잡히지 않은 오류가 있더라도 무조건 실행
	}
_____________________________________________________________________________________________________
API (Application Programming Interface)

	개발에 필요한 라이브러리들의 집합.
	선배 개발자들이 만들어 놓은 소스코드의 집합.

	- 내부 API
			JDK 설치 시 제공해주는 기본 API

	- 외부 API
			선배 개발자들이 개발한 패키지 및 클래스들을 의미한다.
			보통 JAR파일로 배포하며 자바 프로젝트의 build path에 추가하여 사용할 수 있다.
_____________________________________________________________________________________________________
    password : sflc zpdw jwns tkca

    API Key : NCSJU7YIYC27PRQA

    API Secret : T5Z2KJR0GNAYI1OOP7MQJO3J5LBAARNE
_____________________________________________________________________________________________________
JAR 파일로 배포하기

     배포할 클래스 또는 패키지 우클릭
     > Export > JAVA/JAR file 선택 > Next
     > destination을 원하는 경로로 선택
     > Export Java source files... 체크
     > Finish

JAR 파일을 프로젝트에 추가하기

     배포된 JAR파일을 다운 받기
     > 프로젝트 우클릭 > Build Path > Configure Build Path
     > Libraries 탭 클릭 > ClassPath(안되면 ModulePath) 클릭 > Add External JARs
     > 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply and Close
_____________________________________________________________________________________________________
Object 클래스

	최상위 부모 클래스로서, 모든 클래스는 자동으로 Object를 상속받는다.

	1.toString()
		항상 객체명을 출력할 때에는 toString()을 붙여서 출력해준다.
		따라서 객체명만 출력 메소드에 전달하더라도 toString()의 문자열 값이 출력된다.
		기본적으로 Object에서 선언된 toString()은 소속과 필드 주소를 문자열로 리턴해주지만,
		실사용에서는 불필요한 정보이기 떄문에, 재정의 후 필드의 정보를 확인하도록 구현한다.
		실무에서는 클래스 선언 시 각 필드의 초기화 여부를 확인할 때 toString()을 재정의하여 사용한다.  

	2. equlas()
		주소값을 비교하는 메소드이며 ==과 동일하다
		String 클래스에서 eqauls()를 값 비교로 재정의 하여 사용하기 때문에
		문자열 비교는 무조건 equals()로 사용한다.
		만약 주소 비교가 아닌 원하는 필드의 비교가 필요하다면 반드시 eqauls()를 재정의해서 사용해야 한다.

	3. hashCode()
		JVM에서 관리하는 중복 없는 값으로, 실제 메모리에 할당되는 주소와 다르다.
		※ 컬렉션 프레임워크 챕터에서 재정의 목적을 이해하도록 한다.
_____________________________________________________________________________________________________
Wrapper Class

	기본 자료형들의 클래스 타입,
	클래스타입 객체 = new 클래스타입(일반타입의 값);
	클래스타입 객체 = 클래스타입.valueOf(일반타입의 값);
	일반타입 변수 = 객체.000Value();
_____________________________________________________________________________________________________
알고리즘

	어떤 문제가 발생되었을 때 해결할 수 있는 절차 혹은 순서.

자료구조(저장소)

	의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합.
	저장소의 종류에 대해 알아보고 목적과 상황에 맞게 골라 사용하자.

Collection Framework(컬렉션 프레임워크)

	많은 데이터를 쉽고 효과적으로 관리할 수 있는 자료구조 클래스들의 집합.

List extends Collection

	List는 인터페이스이다. List를 구현한 클래스들은 아래와 같다.

	1. Vector : 용량관리, 보안성 강화
	2. LinkedList : 넣을떄는 빨라도 원하는 위치의 데이터를 가져오는 것이 상대적으로 느리다.
	3. ArrayList : 인덱스로 데이터를 관리한다. 컬렉션 클래스 중 실무에서 가장 많이 사용되는 클래스이다.
			배열의 특징인 인덱스를 이용하여 값을 저장하고 관리한다.
			몇개의 데이터를 넣을지 모를때 사용한다.

	※ 배열과 ArrayList의 차이
			배열은 길이에 제한을 두어야 할 때 자주 사용되고,
			ArrayList는 몇 개의 데이터가 들어올지 알 수 없을 때 사용한다.
_____________________________________________________________________________________________________
Set(집합)

	Set은 인터페이스이다. Set을 지정받아 구현한 대표적인 클래스는
	HashSet이다. List와 마찬가지로 collection 인터페이스를 상속받은 인터페이스이다.

HashSet

	집합에서 중복되는 원소를 포함할 수 없는 것처럼 HashSet이라는 자료구조는 중복된 값을 무시한다.
	저장된 값들은 순서가 없기 때문에 저장된 값들은 가져다 쓸 수 없다.
	값의 유무 검사에 특화되어 있는 자료구조이며, 해시코드를 사용하여 검사하기 때문에
	속도가 상대적으로 빠르다.

Iterator

	순서가 없는 객체에 순서를 부여하거나, 순서가 있어도 Iterator 방식의 순서로 변경할 때 사용한다.
	이 때 해당 객체에 iterator() 메소드를 사용하고, 이 메소드의 리턴 타입은 Iterator 타입이다.
	hasNext()를 사용하면 다음 값이 있는지 검사할 수 있고 없다면 false이다.
	next()를 사용하면 다음 값을 가져올 수 있다.
_____________________________________________________________________________________________________
Map

	Set과 Collection 2개의 자료구조를 하나로 합친 자료구조이다.
	List와 Set처럼 Collection을 상속받지 않았고, 독립적인 자료구조이다.
	
HashMap(서버 간 데티어 교환)

	Key와 Value, 한 쌍으로 저장되며, 검색의 목적을 가지고 있다.
	Key에 중복된 값을 넣으면, Value가 최근 값으로 수정되고,
	중복되지 않은 값을 넣으면 새롭게 추가된다.
	단, Value는 중복을 허용한다.
_____________________________________________________________________________________________________
프로그램

	실행이 안된 상태.

프로세스

	실행중인 프로그램.

쓰레드

	프로세스 내의 작업 처리 경로.

	- 싱글 쓰레드(단일 쓰레드)
		처리 경로를 한 개만 가지고 있기 때문에 직렬적이다.
		한 번에 하나씩 처리하기 때문에 상대적으로 비효율적이다.
		하지만 하나의 작업에 문제가 발생하더라도 다른 작업은 시작하지 않았기 때문에
		다른 작업에는 문제가 발생하지 않는다. 따라서 안정성이 보장된다.
		또한 멀티 쓰레드에 비해 설계가 쉽다.

	- 멀티 쓰레드(다중 쓰레드)
		하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례로 처리한다. 
		여러 개의 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다.
		하나의 쓰레드 문제 발생 시 모든 쓰레드에 문제가 발생하게 된다.
		멀티 쓰레드로 설계한다면, 처리량 증가, 효율성 증가, 처리비용 감소의 장점이 있기 때문에
		이러한 단점을 감수하고 설계하는 편이다.
_____________________________________________________________________________________________________
멀티 쓰레드 구현 방법

	핵심: run() 메소드 재정의

	1. Thread 클래스 상속
	2. Runnable 인터페이스 구현

[실습]

	동석이네 동물원에는 3마리의 동물이 있다.
	각 동물은 울음 소리가 다르고 2마리의 동물은 동시에 운다.
	나머지 1마리 동물은 2마리 동물이 모두 울고 나면 마지막에 운다.

	패키지명: threadTask

	※ 클래스는 2개만 선언한다.
	※ 반드시 join()을 사용한다.
	※ 각 동물은 10번씩만 운다.
	※ 람다식을 사용한다.
_____________________________________________________________________________________________________
동기화(Synchronized)

	하나의 쓰레드가 자원에 접근 중일 때 다른 쓰레드가 동시에 같은 자원을 접근하지 못하게 막는 것.
	즉, 자원 공유 문제를 해결할 수 있고 각 쓰레드를 제어해야 할 때에도 자주 사용된다.

동기화 문법

	- 블록
		synchronized(mutex) {
			...
		}

		영역 전체에 동기화가 걸린다.

	- 키워드
		synchronized
		메소드 리턴 타입 앞에 작성하면 해당 메소드가 전체 동기화에 걸린다.

파일 입출력(자바기준)

	Stream이라는 연결통로를 통해 원본 데이터가 알맞은 인코딩 방식으로 전송된다.
	byte 단위로 입출력되기 때문에 개별처리이며, 상세 연산이 필요하지 않다면
	Buffer를 사용한 입출력을 권장한다. Buffer를 사용하면 일괄처리가 가능해진다.

Writer(출력)

	BufferedWriter
		버퍼를 사용하는 출력클래스

	FileWriter
		전달한 경로의 파일을 출력의 목적으로 열어준다.
		전달한 경로에 파일이 없다면 새롭게 만든 후 열어준다.

Reader(입력)

	BufferedReader
		버퍼를 사용하는 입력클래스

	FileReader
		전달한 경로의 파일을 입력의 목적으로 열어준다.
		전달한 경로에 파일이 없다면 FileNotFoundException이 발생한다.

File

	전달한 경로에 있는 파일의 정보를 담는 타입.
	디렉터리 생성, 해당 경로의 전체 파일 목록, 파일 삭제 등
_____________________________________________________________________________________________________
JDBC(Java Database Connectivity)

		Java와 RDB 간의 연결을 위한 기술

소프트웨어 디자인 설계 패턴 

    ▶ MVC 패턴
    
	      M(Model) : 테이블에서 조회된 결과 값을 담기 위한 변수들이 선언된 클래스
			      - 클래스명 뒤에 VO 또는 DTO라는 문자열을 붙여준다.
			      - VO(Value Object) :  테이블을 보고 그대로 만든 객체, 단일 테이블 조회
			      - DTO(Data Transfer Object) : 화면에 결과를 한번에 묶어서 전달할 객체, 여러 테이블 조회

	      V(View) : 사용자에게 보여질 화면을 구성하는 부분
         
	      C(Controller) : JSP 챕터에서 이해할 수 있다.
			      - Controller에 작성된 코드가 길어질 수 밖에 없다.
			      - 이  때문에 Controller에서 작성한 코드 중 DBMS SQL문 관련 코드를 분리하기도 한다.
			      - 이렇[게 분리한 SQL문 관련코드는 DAO라는 클래스에 분리한다.
			      - DAO는 Data Accecss Object의 축약어이다.
			      - 조회 결과는 보통 VO 또는 DTO에 담겨서 리턴된다.
